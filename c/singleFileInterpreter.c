/** The following code is generated by Claude Haiku based on my
 * parser_executor_lexer_all_in_one.py as prompt. But the code is not working
 * correctly... I WILL FIX IT IN THE NEAR FUTURE.*/
#include <ctype.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_TOKEN_LENGTH 256
#define MAX_EXPR_LENGTH 1024
#define MAX_VARS 100
#define MAX_PARAMS 10

typedef enum { TYPE_FLOAT, TYPE_STRING, TYPE_LAMBDA, TYPE_UNDEFINED } ObjType;

typedef struct Obj {
  ObjType type;
  union {
    double float_val;
    char *string_val;
    struct {
      char *expr;
      char **vars;
      int var_count;
    } lambda;
  } value;
} Obj;

typedef struct Env {
  Obj *vars[MAX_VARS];
  char *var_names[MAX_VARS];
  int var_count;
  struct Env *father;
  bool end;
} Env;

// Function prototypes
Obj *create_float_obj(double val);
Obj *create_string_obj(const char *val);
Obj *create_lambda_obj(const char *expr, char **vars, int var_count);
void free_obj(Obj *obj);
Env *create_env(Env *father);
bool env_in(Env *env, const char *tok);
Obj *env_get(Env *env, const char *tok);
void env_set(Env *env, const char *tok, Obj *obj);
void free_env(Env *env);

int get_next_word(int i, const char *expr, char *out);
int skip_expr(int i, const char *expr);
int eval_expr(Env *env, int i, const char *expr, Obj **result);

// Arithmetic functions
double add(double a, double b) { return a + b; }
double subtract(double a, double b) { return a - b; }
double multiply(double a, double b) { return a * b; }
double divide(double a, double b) { return a / b; }

// Object creation functions
Obj *create_float_obj(double val) {
  Obj *obj = malloc(sizeof(Obj));
  obj->type = TYPE_FLOAT;
  obj->value.float_val = val;
  return obj;
}

Obj *create_string_obj(const char *val) {
  Obj *obj = malloc(sizeof(Obj));
  obj->type = TYPE_STRING;
  obj->value.string_val = strdup(val);
  return obj;
}

Obj *create_lambda_obj(const char *expr, char **vars, int var_count) {
  Obj *obj = malloc(sizeof(Obj));
  obj->type = TYPE_LAMBDA;
  obj->value.lambda.expr = strdup(expr);
  obj->value.lambda.vars = malloc(var_count * sizeof(char *));
  for (int i = 0; i < var_count; i++) {
    obj->value.lambda.vars[i] = strdup(vars[i]);
  }
  obj->value.lambda.var_count = var_count;
  return obj;
}

void free_obj(Obj *obj) {
  if (!obj)
    return;
  switch (obj->type) {
  case TYPE_STRING:
    free(obj->value.string_val);
    break;
  case TYPE_LAMBDA:
    free(obj->value.lambda.expr);
    for (int i = 0; i < obj->value.lambda.var_count; i++) {
      free(obj->value.lambda.vars[i]);
    }
    free(obj->value.lambda.vars);
    break;
  default:
    break;
  }
  free(obj);
}

Env *create_env(Env *father) {
  Env *env = malloc(sizeof(Env));
  env->var_count = 0;
  env->father = father;
  env->end = false;
  return env;
}

void free_env(Env *env) {
  if (!env)
    return;
  for (int i = 0; i < env->var_count; i++) {
    free(env->var_names[i]);
    free_obj(env->vars[i]);
  }
  free(env);
}

bool env_in(Env *env, const char *tok) {
  for (int i = 0; i < env->var_count; i++) {
    if (strcmp(env->var_names[i], tok) == 0) {
      return true;
    }
  }
  return env->father ? env_in(env->father, tok) : false;
}

Obj *env_get(Env *env, const char *tok) {
  for (int i = 0; i < env->var_count; i++) {
    if (strcmp(env->var_names[i], tok) == 0) {
      return env->vars[i];
    }
  }
  return env->father ? env_get(env->father, tok) : NULL;
}

void env_set(Env *env, const char *tok, Obj *obj) {
  char *new_tok = strdup(tok);
  env->var_names[env->var_count] = new_tok;
  env->vars[env->var_count] = obj;
  env->var_count++;
}

// Special built-in functions
int if_func(Env *env, int i, const char *expr, Obj **result) {
  Obj *cond;
  i = eval_expr(env, i, expr, &cond);

  bool condition = (cond->type == TYPE_FLOAT && cond->value.float_val != 0);

  if (condition) {
    i = eval_expr(env, i, expr, result);
    char next_tok[MAX_TOKEN_LENGTH];
    get_next_word(i, expr, next_tok);
    if (strcmp(next_tok, ")") == 0) {
      return i;
    }
    i = skip_expr(i, expr);
    return i;
  } else {
    i = skip_expr(i, expr);
    return eval_expr(env, i, expr, result);
  }
}

int define_func(Env *env, int i, const char *expr, Obj **result) {
  char tok[MAX_TOKEN_LENGTH];
  i = get_next_word(i, expr, tok);
  i = eval_expr(env, i, expr, result);
  env_set(env, tok, *result);
  return i;
}

int lambda_func(Env *env, int i, const char *expr, Obj **result) {
  char tok[MAX_TOKEN_LENGTH];
  i = get_next_word(i, expr, tok); // skip "("

  char *params[MAX_PARAMS];
  int param_count = 0;

  while (true) {
    i = get_next_word(i, expr, tok);
    if (strcmp(tok, ")") == 0)
      break;
    if (strcmp(tok, ",") == 0)
      continue;
    params[param_count++] = strdup(tok);
  }

  int start = i;
  int j = i;
  int prev = i;

  char next_tok[MAX_TOKEN_LENGTH];
  get_next_word(j, expr, next_tok);
  while (strcmp(next_tok, ")") != 0) {
    j = skip_expr(j, expr);
    get_next_word(j, expr, next_tok);
  }
  i = j;

  char lambda_expr[MAX_EXPR_LENGTH];
  strncpy(lambda_expr, expr + start, j - start);
  lambda_expr[j - start] = '\0';

  *result = create_lambda_obj(lambda_expr, params, param_count);

  // Free temporary param strings
  for (int k = 0; k < param_count; k++) {
    free(params[k]);
  }

  return i;
}

int return_func(Env *env, int i, const char *expr, Obj **result) {
  env->end = true;
  return eval_expr(env, i, expr, result);
}

int display_func(Env *env, int i, const char *expr, Obj **result) {
  i = eval_expr(env, i, expr, result);

  switch ((*result)->type) {
  case TYPE_FLOAT:
    printf("%f\n", (*result)->value.float_val);
    break;
  case TYPE_STRING:
    printf("%s\n", (*result)->value.string_val);
    break;
  default:
    printf("Unsupported type for display\n");
  }

  return i;
}

// Parsing and evaluation functions
int get_next_word(int i, const char *expr, char *out) {
  while (isspace(expr[i]))
    i++;

  if (expr[i] == '(' || expr[i] == ')' || expr[i] == '"') {
    out[0] = expr[i];
    out[1] = '\0';
    return i + 1;
  }

  int j = 0;
  while (i < strlen(expr) && !isspace(expr[i]) && expr[i] != '(' &&
         expr[i] != ')') {
    out[j++] = expr[i++];
  }
  out[j] = '\0';

  return i;
}

int skip_expr(int i, const char *expr) {
  char tok[MAX_TOKEN_LENGTH];
  i = get_next_word(i, expr, tok);

  if (strcmp(tok, "(") != 0) {
    return get_next_word(i, expr, tok);
  }

  int l_minus_r = 1;
  while (l_minus_r != 0) {
    i = get_next_word(i, expr, tok);
    if (strcmp(tok, "(") == 0)
      l_minus_r++;
    if (strcmp(tok, ")") == 0)
      l_minus_r--;
  }

  return i;
}

int eval_arithmetic(const char *op, Obj **numberObjs, int numCount,
                    Obj **result) {
  double out = numberObjs[0]->value.float_val;
  for (int i = 1; i < numCount; i++) {
    if (strcmp(op, "+") == 0)
      out = add(out, numberObjs[i]->value.float_val);
    else if (strcmp(op, "-") == 0)
      out = subtract(out, numberObjs[i]->value.float_val);
    else if (strcmp(op, "*") == 0)
      out = multiply(out, numberObjs[i]->value.float_val);
    else if (strcmp(op, "/") == 0)
      out = divide(out, numberObjs[i]->value.float_val);
  }
  *result = create_float_obj(out);
  return 0;
}

int eval_lambda_call(Env *env, Obj *lambda, Obj **params, int paramCount,
                     Obj **result) {
  Env *new_env = create_env(env);

  for (int j = 0; j < lambda->value.lambda.var_count; j++) {
    env_set(new_env, lambda->value.lambda.vars[j], params[j]);
  }

  int j = 0;
  while (j < strlen(lambda->value.lambda.expr)) {
    j = eval_expr(new_env, j, lambda->value.lambda.expr, result);
    if (new_env->end) {
      break;
    }
  }

  free_env(new_env);
  return j;
}

int eval_expr(Env *env, int i, const char *expr, Obj **result) {
  char tok[MAX_TOKEN_LENGTH];
  i = get_next_word(i, expr, tok);

  if (strcmp(tok, "(") == 0) {
    int start = i;
    int bracket_count = 1;

    while (bracket_count > 0) {
      i = get_next_word(i, expr, tok);
      if (strcmp(tok, "(") == 0)
        bracket_count++;
      if (strcmp(tok, ")") == 0)
        bracket_count--;
    }

    i = start;
    int out = eval_expr(env, i, expr, result);

    char end_tok[MAX_TOKEN_LENGTH];
    out = get_next_word(out, expr, end_tok);

    return out;
  }

  if (strspn(tok, "0123456789") == strlen(tok)) {
    *result = create_float_obj(atof(tok));
    return i;
  }

  if (tok[0] == '"') {
    memmove(tok, tok + 1, strlen(tok));
    tok[strlen(tok) - 1] = '\0';
    *result = create_string_obj(tok);
    return i;
  }

  if (strcmp(tok, "+") == 0 || strcmp(tok, "-") == 0 || strcmp(tok, "*") == 0 ||
      strcmp(tok, "/") == 0) {
    Obj *numberObjs[MAX_PARAMS];
    int numCount = 0;
    char next_tok[MAX_TOKEN_LENGTH];

    while (true) {
      i = get_next_word(i, expr, next_tok);
      if (strcmp(next_tok, ")") == 0)
        break;
      i = eval_expr(env, i, expr, &numberObjs[numCount++]);
    }

    eval_arithmetic(tok, numberObjs, numCount, result);
    return i;
  }

  if (strcmp(tok, "if") == 0)
    return if_func(env, i, expr, result);
  if (strcmp(tok, "define") == 0)
    return define_func(env, i, expr, result);
  if (strcmp(tok, "lambda") == 0)
    return lambda_func(env, i, expr, result);
  if (strcmp(tok, "return") == 0)
    return return_func(env, i, expr, result);
  if (strcmp(tok, "display") == 0)
    return display_func(env, i, expr, result);

  if (env_in(env, tok)) {
    Obj *var = env_get(env, tok);

    if (var->type != TYPE_LAMBDA) {
      *result = var;
      return i;
    }

    char next_tok[MAX_TOKEN_LENGTH];
    Obj *params[MAX_PARAMS];
    int paramCount = 0;

    while (true) {
      i = get_next_word(i, expr, next_tok);
      if (strcmp(next_tok, ")") == 0)
        break;
      i = eval_expr(env, i, expr, &params[paramCount++]);
    }

    return eval_lambda_call(env, var, params, paramCount, result);
  }

  fprintf(stderr, "Undefined symbol: %s\n", tok);
  exit(1);
}

void repl(Env *env) {
  char expr[MAX_EXPR_LENGTH];
  while (true) {
    printf("pyLisp> ");
    if (fgets(expr, sizeof(expr), stdin) == NULL)
      break;

    expr[strcspn(expr, "\n")] = 0; // Remove newline

    int i = 0;
    Obj *out;
    while (i < strlen(expr)) {
      i = eval_expr(env, i, expr, &out);
      switch (out->type) {
      case TYPE_FLOAT:
        printf("%f\n", out->value.float_val);
        break;
      case TYPE_STRING:
        printf("%s\n", out->value.string_val);
        break;
      case TYPE_LAMBDA:
        printf("Lambda function\n");
        break;
      default:
        printf("Unsupported type\n");
      }
      free_obj(out);
    }
  }
}

void test(Env *env) {
  // const char *expr = "(define recur (lambda (x) (if x (return (recur "
  //                    "(- x 1))) 0)) ) (recur 2)";

  const char *expr = "(define a 2)(+ a 2)";

  int i = 0;
  Obj *out;
  while (i < strlen(expr)) {
    i = eval_expr(env, i, expr, &out);
    switch (out->type) {
    case TYPE_FLOAT:
      printf("%f\n", out->value.float_val);
      break;
    case TYPE_STRING:
      printf("%s\n", out->value.string_val);
      break;
    default:
      printf("Unsupported type\n");
    }
    free_obj(out);
  }

  repl(env);
}

int main() {
  Env *env = create_env(NULL);

  // Uncomment the line below to start in REPL mode
  // repl(env);

  // Run the test
  test(env);

  // Clean up
  free_env(env);

  return 0;
}